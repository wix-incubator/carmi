// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`macros carmi-react: carmi-react 1`] = `
"
// @carmi
import carmi from './macro'
const { root } = require('../../index');
const {createElement} = require('../../jsx');
const todosList = <div>{root.get(0)}</div>;
module.exports = {todosList};

      ↓ ↓ ↓ ↓ ↓ ↓

module.exports = function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */true) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { library, createInvalidatedSet } = require('carmi/src/lib/optimizing');const $trackingMap = new WeakMap();const $trackingWildcards = new WeakMap();const $invalidatedMap = new WeakMap();const $invalidatedRoots = createInvalidatedSet(null, null);let $first = true;let $tainted = new WeakSet();$invalidatedMap.set($res, $invalidatedRoots);const { updateTainted, untrack, invalidate, setOnObject, deleteOnObject, setOnArray, truncateArray, track, trackPath, triggerInvalidations, initOutput, emptyObj, emptyArr, nullFunc, mapValuesOpt, filterByOpt, mapOpt, recursiveSteps, cascadeRecursiveInvalidations, recursiveCacheFunc, recursiveMapOpt, recursiveMapValuesOpt, keyByOpt, mapKeysOpt, filterCacheFunc, filterOpt, anyOpt, anyValuesOpt, groupByOpt, valuesOrKeysCacheFunc, valuesOpt, keysOpt, getEmptyArray, getEmptyObject, array, object, call, bind, assignOpt, defaultsOpt, flattenOpt, size, isEmpty, last, sumOpt, range, invalidatePath, set, splice } = library({ $trackingMap, $trackingWildcards, $invalidatedMap, $tainted, $res, $funcLib, $funcLibRaw, getAssignableObject, ensurePath, applySetter });const $topLevel = new Array(2).fill(null);function $todosListBuild($tracked) {
      const newValue = call($tracked, [\\"createElement\\", $topLevel[0 /*\\"$array_temp_4_19_1\\"*/]], 2, 2);return newValue;
    }function $array_temp_4_19_1Build($tracked) {
      const newValue = array($tracked, [\\"div\\", null, $model[0]], 5, 3);return newValue;
    }const builderFunctions = [$array_temp_4_19_1Build, $todosListBuild];const builderNames = [\\"$array_temp_4_19_1\\", \\"todosList\\"];function updateDerived() {
      for (let i = 0; i < 2; i++) {
        if ($first || $invalidatedRoots.has(i)) {
          const newValue = builderFunctions[i]([$invalidatedRoots, i]);setOnArray($topLevel, i, newValue, $first);if (!$first) {
            $invalidatedRoots.delete(i);
          }if (builderNames[i]) {
            $res[builderNames[i]] = newValue;
          }
        }
      }
    }let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();$first = false;$tainted = new WeakSet();updateTainted($tainted);$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function ensurePath(path) {
      if (path.length < 2) {
        return;
      }if (path.length > 2) {
        ensurePath(path.slice(0, path.length - 1));
      }const lastObjectKey = path[path.length - 2];const assignable = getAssignableObject(path, path.length - 2);if (assignable[lastObjectKey]) {
        return;
      }const lastType = typeof path[path.length - 1];assignable[lastObjectKey] = lastType === 'number' ? [] : {};
    }function getAssignableObject(path, index) {
      return path.slice(0, index).reduce((agg, p) => agg[p], $model);
    }function push(path, value) {
      ensurePath([...path, 0]);const arr = getAssignableObject(path, path.length);splice([...path, arr.length], 0, value);
    }function applySetter(object, key, value) {
      if (typeof value === 'undefined') {
        delete object[key];
      } else {
        object[key] = value;
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */true) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
}();
"
`;

exports[`macros magic-comment: magic-comment 1`] = `
"
// @carmi
import carmi from './macro'
const { root } = require('../../index');
module.exports = { first: root.get(0), second: root.get(1) };

      ↓ ↓ ↓ ↓ ↓ ↓

module.exports = function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */true) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { library, createInvalidatedSet } = require('carmi/src/lib/optimizing');const $trackingMap = new WeakMap();const $trackingWildcards = new WeakMap();const $invalidatedMap = new WeakMap();const $invalidatedRoots = createInvalidatedSet(null, null);let $first = true;let $tainted = new WeakSet();$invalidatedMap.set($res, $invalidatedRoots);const { updateTainted, untrack, invalidate, setOnObject, deleteOnObject, setOnArray, truncateArray, track, trackPath, triggerInvalidations, initOutput, emptyObj, emptyArr, nullFunc, mapValuesOpt, filterByOpt, mapOpt, recursiveSteps, cascadeRecursiveInvalidations, recursiveCacheFunc, recursiveMapOpt, recursiveMapValuesOpt, keyByOpt, mapKeysOpt, filterCacheFunc, filterOpt, anyOpt, anyValuesOpt, groupByOpt, valuesOrKeysCacheFunc, valuesOpt, keysOpt, getEmptyArray, getEmptyObject, array, object, call, bind, assignOpt, defaultsOpt, flattenOpt, size, isEmpty, last, sumOpt, range, invalidatePath, set, splice } = library({ $trackingMap, $trackingWildcards, $invalidatedMap, $tainted, $res, $funcLib, $funcLibRaw, getAssignableObject, ensurePath, applySetter });const $topLevel = new Array(2).fill(null);function $firstBuild($tracked) {
      const newValue = $model[0];return newValue;
    }function $secondBuild($tracked) {
      const newValue = $model[1];return newValue;
    }const builderFunctions = [$firstBuild, $secondBuild];const builderNames = [\\"first\\", \\"second\\"];function updateDerived() {
      for (let i = 0; i < 2; i++) {
        if ($first || $invalidatedRoots.has(i)) {
          const newValue = builderFunctions[i]([$invalidatedRoots, i]);setOnArray($topLevel, i, newValue, $first);if (!$first) {
            $invalidatedRoots.delete(i);
          }if (builderNames[i]) {
            $res[builderNames[i]] = newValue;
          }
        }
      }
    }let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();$first = false;$tainted = new WeakSet();updateTainted($tainted);$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function ensurePath(path) {
      if (path.length < 2) {
        return;
      }if (path.length > 2) {
        ensurePath(path.slice(0, path.length - 1));
      }const lastObjectKey = path[path.length - 2];const assignable = getAssignableObject(path, path.length - 2);if (assignable[lastObjectKey]) {
        return;
      }const lastType = typeof path[path.length - 1];assignable[lastObjectKey] = lastType === 'number' ? [] : {};
    }function getAssignableObject(path, index) {
      return path.slice(0, index).reduce((agg, p) => agg[p], $model);
    }function push(path, value) {
      ensurePath([...path, 0]);const arr = getAssignableObject(path, path.length);splice([...path, arr.length], 0, value);
    }function applySetter(object, key, value) {
      if (typeof value === 'undefined') {
        delete object[key];
      } else {
        object[key] = value;
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */true) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
}();
"
`;

exports[`macros template-literal: template-literal 1`] = `
"
const carmi = require('./macro')

const modelBuilder = carmi\`
  const {root} = require('../..')
  module.exports = {all: root.get('list'), first: root.get('list').get(0)}
\`

      ↓ ↓ ↓ ↓ ↓ ↓

const modelBuilder = (function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */true) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { library, createInvalidatedSet } = require('carmi/src/lib/optimizing');const $trackingMap = new WeakMap();const $trackingWildcards = new WeakMap();const $invalidatedMap = new WeakMap();const $invalidatedRoots = createInvalidatedSet(null, null);let $first = true;let $tainted = new WeakSet();$invalidatedMap.set($res, $invalidatedRoots);const { updateTainted, untrack, invalidate, setOnObject, deleteOnObject, setOnArray, truncateArray, track, trackPath, triggerInvalidations, initOutput, emptyObj, emptyArr, nullFunc, mapValuesOpt, filterByOpt, mapOpt, recursiveSteps, cascadeRecursiveInvalidations, recursiveCacheFunc, recursiveMapOpt, recursiveMapValuesOpt, keyByOpt, mapKeysOpt, filterCacheFunc, filterOpt, anyOpt, anyValuesOpt, groupByOpt, valuesOrKeysCacheFunc, valuesOpt, keysOpt, getEmptyArray, getEmptyObject, array, object, call, bind, assignOpt, defaultsOpt, flattenOpt, size, isEmpty, last, sumOpt, range, invalidatePath, set, splice } = library({ $trackingMap, $trackingWildcards, $invalidatedMap, $tainted, $res, $funcLib, $funcLibRaw, getAssignableObject, ensurePath, applySetter });const $topLevel = new Array(2).fill(null);function $allBuild($tracked) {
      const newValue = $model[\\"list\\"];return newValue;
    }function $firstBuild($tracked) {
      const newValue = $topLevel[0 /*\\"all\\"*/][0];return newValue;
    }const builderFunctions = [$allBuild, $firstBuild];const builderNames = [\\"all\\", \\"first\\"];function updateDerived() {
      for (let i = 0; i < 2; i++) {
        if ($first || $invalidatedRoots.has(i)) {
          const newValue = builderFunctions[i]([$invalidatedRoots, i]);setOnArray($topLevel, i, newValue, $first);if (!$first) {
            $invalidatedRoots.delete(i);
          }if (builderNames[i]) {
            $res[builderNames[i]] = newValue;
          }
        }
      }
    }let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();$first = false;$tainted = new WeakSet();updateTainted($tainted);$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function ensurePath(path) {
      if (path.length < 2) {
        return;
      }if (path.length > 2) {
        ensurePath(path.slice(0, path.length - 1));
      }const lastObjectKey = path[path.length - 2];const assignable = getAssignableObject(path, path.length - 2);if (assignable[lastObjectKey]) {
        return;
      }const lastType = typeof path[path.length - 1];assignable[lastObjectKey] = lastType === 'number' ? [] : {};
    }function getAssignableObject(path, index) {
      return path.slice(0, index).reduce((agg, p) => agg[p], $model);
    }function push(path, value) {
      ensurePath([...path, 0]);const arr = getAssignableObject(path, path.length);splice([...path, arr.length], 0, value);
    }function applySetter(object, key, value) {
      if (typeof value === 'undefined') {
        delete object[key];
      } else {
        object[key] = value;
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */true) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
})();
"
`;
