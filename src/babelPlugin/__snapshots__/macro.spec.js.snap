// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`macros carmi-react: carmi-react 1`] = `
"
// @carmi
import carmi from './macro'
const { root } = require('../../index');
const {createElement} = require('../../jsx');
const todosList = <div>{root.get(0)}</div>;
module.exports = {todosList};

      ↓ ↓ ↓ ↓ ↓ ↓

module.exports = function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */false) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { createLibrary } = require('carmi/src/lib/optimizing');const { any, anyValues, array, assign, bind, call, defaults, filter, filterBy, flatten, groupBy, isEmpty, keyBy, keys, last, map, mapKeys, mapValues, object, push, range, recursiveMap, recursiveMapValues, set, size, splice, sum, trackPath, values, updateModel, resetTainted } = createLibrary($res, $funcLib, $funcLibRaw);const $topLevel = new Array(2).fill(null);function $todosListBuild($tracked) {
      const newValue = call($tracked, [\\"createElement\\", $topLevel[0]], 2, 2);return newValue;
    }function $array_temp_4_19_1Build($tracked) {
      const newValue = array($tracked, [\\"div\\", null, $model[0]], 5, 3);return newValue;
    }const builderFunctions = [$array_temp_4_19_1Build, $todosListBuild];const builderNames = [\\"\\", \\"todosList\\"];const updateDerived = () => updateModel(2, builderFunctions, $topLevel, builderNames);let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();resetTainted();$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */false) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
}();
"
`;

exports[`macros magic-comment: magic-comment 1`] = `
"
// @carmi
import carmi from './macro'
const { root } = require('../../index');
module.exports = { first: root.get(0), second: root.get(1) };

      ↓ ↓ ↓ ↓ ↓ ↓

module.exports = function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */false) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { createLibrary } = require('carmi/src/lib/optimizing');const { any, anyValues, array, assign, bind, call, defaults, filter, filterBy, flatten, groupBy, isEmpty, keyBy, keys, last, map, mapKeys, mapValues, object, push, range, recursiveMap, recursiveMapValues, set, size, splice, sum, trackPath, values, updateModel, resetTainted } = createLibrary($res, $funcLib, $funcLibRaw);const $topLevel = new Array(2).fill(null);function $firstBuild($tracked) {
      const newValue = $model[0];return newValue;
    }function $secondBuild($tracked) {
      const newValue = $model[1];return newValue;
    }const builderFunctions = [$firstBuild, $secondBuild];const builderNames = [\\"first\\", \\"second\\"];const updateDerived = () => updateModel(2, builderFunctions, $topLevel, builderNames);let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();resetTainted();$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */false) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
}();
"
`;

exports[`macros template-literal: template-literal 1`] = `
"
const carmi = require('./macro')

const modelBuilder = carmi\`
  const {root} = require('../..')
  module.exports = {all: root.get('list'), first: root.get('list').get(0)}
\`

      ↓ ↓ ↓ ↓ ↓ ↓

const modelBuilder = (function () {
  return function model($model, $funcLibRaw, $batchingStrategy) {
    let $funcLib = $funcLibRaw;if ( /* DEBUG */false) {
      $funcLib = !$funcLibRaw || typeof Proxy === 'undefined' ? $funcLibRaw : new Proxy($funcLibRaw, { get: (target, functionName) => {
          if (target[functionName]) {
            return target[functionName];
          }throw new TypeError(\`Trying to call undefined function: \${functionName} \`);
        } });
    }function mathFunction(name, source) {
      return arg => {
        const type = typeof arg;if (type !== 'number') {
          throw new TypeError(\`Trying to call \${JSON.stringify(arg)}.\${name}. Expects number, received \${type} at \${source}\`);
        }return Math[name](arg);
      };
    }function checkTypes(input, name, types, functionName, source) {
      function checkType(type) {
        const isArray = Array.isArray(input);return type == 'array' && isArray || type === typeof input && !isArray;
      }if (types.some(checkType)) {
        return;
      }const asString = typeof input === 'object' ? JSON.stringify(input) : input;throw new TypeError(\`\${functionName} expects \${types.join('/')}. \${name} at \${source}: \${asString}.\${functionName}\`);
    }const $res = { $model };const $listeners = new Set();const { createLibrary } = require('carmi/src/lib/optimizing');const { any, anyValues, array, assign, bind, call, defaults, filter, filterBy, flatten, groupBy, isEmpty, keyBy, keys, last, map, mapKeys, mapValues, object, push, range, recursiveMap, recursiveMapValues, set, size, splice, sum, trackPath, values, updateModel, resetTainted } = createLibrary($res, $funcLib, $funcLibRaw);const $topLevel = new Array(2).fill(null);function $allBuild($tracked) {
      const newValue = $model[\\"list\\"];return newValue;
    }function $firstBuild($tracked) {
      const newValue = $topLevel[0][0];return newValue;
    }const builderFunctions = [$allBuild, $firstBuild];const builderNames = [\\"all\\", \\"first\\"];const updateDerived = () => updateModel(2, builderFunctions, $topLevel, builderNames);let $inBatch = false;let $batchPending = [];let $inRecalculate = false;function recalculate() {
      if ($inBatch) {
        return;
      }$inRecalculate = true;updateDerived();resetTainted();$inRecalculate = false;if ($batchPending.length) {
        $res.$endBatch();
      } else {
        $listeners.forEach(callback => callback());
      }
    }function $setter(func, ...args) {
      if ($inBatch || $inRecalculate || $batchingStrategy) {
        $batchPending.push({ func, args });if (!$inBatch && !$inRecalculate && $batchingStrategy) {
          $inBatch = true;$batchingStrategy.call($res);
        }
      } else {
        func.apply($res, args);recalculate();
      }
    }Object.assign($res, {}, { $startBatch: () => {
        $inBatch = true;
      }, $endBatch: () => {
        if ($inRecalculate) {
          throw new Error('Can not end batch in the middle of a batch');
        }$inBatch = false;if ($batchPending.length) {
          $batchPending.forEach(({ func, args }) => {
            func.apply($res, args);
          });$batchPending = [];recalculate();
        }
      }, $runInBatch: func => {
        if ($inRecalculate) {
          func();
        } else {
          $res.$startBatch();func();$res.$endBatch();
        }
      }, $addListener: func => {
        $listeners.add(func);
      }, $removeListener: func => {
        $listeners.delete(func);
      }, $setBatchingStrategy: func => {
        $batchingStrategy = func;
      } });if ( /* DEBUG */false) {
      Object.assign($res, { $ast: () => {
          return null;
        }, $source: () => null });
    }recalculate();return $res;
  };
})();
"
`;
